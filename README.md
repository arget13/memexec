# memexec

Right now this is just an ugly proof of concept presented at RootedCon 2023.

`memexecd.c` is the code for the "daemonized" [DDexec](https://github.com/arget13/DDexec) which *listens* on a pipe for requests, which are composed of:
- Size of arguments.
- Arguments (separated by nullbytes).
- Size of program.
- Raw program.
It should be fairly easy to adapt to other IPC methods instead of pipes, like sockets (UNIX or network ones), or shared memory.

`a.php` was part of the demo at RootedCon. In case you get an inverse php shell on a **distroless** -without write permissions anywhere- you can paste the contents of this file in order to load the daemon. Then using the function `memexec()` perform requests load and run remote binaries. It'd be very a very interesting toy to play with, in web environments where you can't get a reverse interactive session you may want to add code like `memexec($_GET['url'], $_GET['args'])`, or modify it in order to read the program from a POST request, and show the output of the program as HTML.

`loader` and `loaderarm` are builds of `memexecd.c`, the shellcodes in `a.php` that load this binaries were generated by [DDexec](https://github.com/arget13/DDexec) and are specific to *these* binaries and won't work correctly when trying to load a different file. On the other hand this files (`loader` and `loaderarm`) aren't the files as produced by gcc because the shellcode only reads the pieces that the program needs loaded in memory, so further processing was made (also produced by DDexec). Additionally, this couple of files are statically compiled and non-PIE, so they are pretty heavy (almost 1MB) and can't load non-PIE binaries. By making a more generic shellcode I will be able to solve all of this problems.
